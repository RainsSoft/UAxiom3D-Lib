{"name":"Uaxiom3d-lib","tagline":"UAxiom3D lib is Extracted from axiom3d,this lib can using in unity3d (unity5),if you are ogre3d/mogre3d/axiom3d developer,this is very useful. this lib conrains : filesystem,factory desgin,WorkQueue,LogManager,ResourceManager,Singleton,Deque,CrossPlatform Buffer, axiom math and more...","body":"\r\n#region Namespace Declarations\r\n\r\nusing System;\r\nusing System.Runtime.InteropServices;\r\nusing System.Threading;\r\n\r\n#endregion Namespace Declarations\r\n\r\nnamespace Axiom.Core {\r\n    public interface ITypePointer<T> {\r\n        T this[int index] { get; set; }\r\n    };\r\n\r\n    [StructLayout(LayoutKind.Explicit)]\r\n    public struct TwoByte {\r\n        [FieldOffset(0)]\r\n        public short Short;\r\n\r\n        [FieldOffset(0)]\r\n        public ushort UShort;\r\n\r\n#if AXIOM_BIG_ENDIAN\r\n\t\t[FieldOffset( 1 )] public byte b0;\r\n\t\t[FieldOffset( 0 )] public byte b1;\r\n#else\r\n        [FieldOffset(0)]\r\n        public byte b0;\r\n\r\n        [FieldOffset(1)]\r\n        public byte b1;\r\n\r\n        public byte[] Bytes {\r\n            get {\r\n                return new[]\r\n\t\t\t\t\t   {\r\n\t\t\t\t\t\tthis.b0, this.b1\r\n\t\t\t\t\t   };\r\n            }\r\n            set {\r\n                this.b0 = value[0];\r\n                this.b1 = value[1];\r\n            }\r\n        }\r\n#endif\r\n    };\r\n\r\n    [StructLayout(LayoutKind.Explicit)]\r\n    public struct FourByte {\r\n        [FieldOffset(0)]\r\n        public float Float;\r\n\r\n        [FieldOffset(0)]\r\n        public int Int;\r\n\r\n        [FieldOffset(0)]\r\n        public uint UInt;\r\n\r\n#if AXIOM_BIG_ENDIAN\r\n\t\t[FieldOffset( 3 )] public byte b0;\r\n\t\t[FieldOffset( 2 )] public byte b1;\r\n\t\t[FieldOffset( 1 )] public byte b2;\r\n\t\t[FieldOffset( 0 )] public byte b3;\r\n#else\r\n        [FieldOffset(0)]\r\n        public byte b0;\r\n\r\n        [FieldOffset(1)]\r\n        public byte b1;\r\n\r\n        [FieldOffset(2)]\r\n        public byte b2;\r\n\r\n        [FieldOffset(3)]\r\n        public byte b3;\r\n#endif\r\n\r\n        public byte[] Bytes {\r\n            get {\r\n                return new[]\r\n\t\t\t\t\t   {\r\n\t\t\t\t\t\tthis.b0, this.b1, this.b2, this.b3\r\n\t\t\t\t\t   };\r\n            }\r\n            set {\r\n                this.b0 = value[0];\r\n                this.b1 = value[1];\r\n                this.b2 = value[2];\r\n                this.b3 = value[3];\r\n            }\r\n        }\r\n    };\r\n\r\n    [StructLayout(LayoutKind.Explicit)]\r\n    public struct EightByte {\r\n        [FieldOffset(0)]\r\n        public double Double;\r\n\r\n        [FieldOffset(0)]\r\n        public long Long;\r\n\r\n        [FieldOffset(0)]\r\n        public ulong ULong;\r\n\r\n#if AXIOM_BIG_ENDIAN\r\n\t\t[FieldOffset( 7 )] public byte b0;\r\n\t\t[FieldOffset( 6 )] public byte b1;\r\n\t\t[FieldOffset( 5 )] public byte b2;\r\n\t\t[FieldOffset( 4 )] public byte b3;\r\n\t\t[FieldOffset( 3 )] public byte b4;\r\n\t\t[FieldOffset( 2 )] public byte b5;\r\n\t\t[FieldOffset( 1 )] public byte b6;\r\n\t\t[FieldOffset( 0 )] public byte b7;\r\n#else\r\n        [FieldOffset(0)]\r\n        public byte b0;\r\n\r\n        [FieldOffset(1)]\r\n        public byte b1;\r\n\r\n        [FieldOffset(2)]\r\n        public byte b2;\r\n\r\n        [FieldOffset(3)]\r\n        public byte b3;\r\n\r\n        [FieldOffset(4)]\r\n        public byte b4;\r\n\r\n        [FieldOffset(5)]\r\n        public byte b5;\r\n\r\n        [FieldOffset(6)]\r\n        public byte b6;\r\n\r\n        [FieldOffset(7)]\r\n        public byte b7;\r\n#endif\r\n\r\n        public byte[] Bytes {\r\n            get {\r\n                return new[]\r\n\t\t\t\t\t   {\r\n\t\t\t\t\t\tthis.b0, this.b1, this.b2, this.b3, this.b4, this.b5, this.b6, this.b7\r\n\t\t\t\t\t   };\r\n            }\r\n            set {\r\n                this.b0 = value[0];\r\n                this.b1 = value[1];\r\n                this.b2 = value[2];\r\n                this.b3 = value[3];\r\n                this.b4 = value[4];\r\n                this.b5 = value[5];\r\n                this.b6 = value[6];\r\n                this.b7 = value[7];\r\n            }\r\n        }\r\n    };\r\n    \r\n    public abstract class BufferBase : DisposableObject, ICloneable {\r\n        #region Fields\r\n\r\n        protected GCHandle PinHandle;\r\n        protected int PinCount;\r\n        private static readonly object _mutex = new object();\r\n\r\n        #endregion Fields\r\n\r\n        public abstract int Ptr { get; set; }\r\n\r\n        /// <summary>\r\n        /// Gets a 32-bit integer that represents the length of this Buffer ( expressed in bytes )\r\n        /// </summary>\r\n        public virtual int Length { get; protected set; }\r\n\r\n        public BufferBase Offset(int offset) {\r\n            Ptr += offset;\r\n            return this;\r\n        }\r\n\r\n        public static BufferBase operator +(BufferBase buffer, int offset) {\r\n            // avoid useless clones\r\n            if (offset == 0) {\r\n                return buffer;\r\n            }\r\n\r\n            var buf = (BufferBase)buffer.Clone();\r\n            buf.Ptr += offset;\r\n            return buf;\r\n        }\r\n\r\n        public static BufferBase operator +(BufferBase buffer, long offset) {\r\n            return buffer + (int)offset;\r\n        }\r\n\r\n        public static BufferBase operator ++(BufferBase buffer) {\r\n            buffer.Ptr++;\r\n            return buffer;\r\n        }\r\n\r\n        protected override void dispose(bool disposeManagedResources) {\r\n            if (!IsDisposed) {\r\n                if (disposeManagedResources) {\r\n                }\r\n\r\n                UnPin(true);\r\n            }\r\n\r\n            base.dispose(disposeManagedResources);\r\n        }\r\n\r\n        public abstract object Clone();\r\n\r\n        public virtual void Copy(BufferBase src, int srcOffset, int destOffset, int length) {\r\n            if (src == null || srcOffset < 0 || destOffset < 0 || length < 0)\r\n                throw new ArgumentException();\r\n\r\n            // Ensure we don't read past the end of either buffer.\r\n            if ((src.Ptr + srcOffset) + length > src.Length || (this.Ptr + destOffset) + length > this.Length)\r\n                throw new ArgumentOutOfRangeException();\r\n        }\r\n\r\n        protected void checkBounds(int value) {\r\n            if (value < 0 || value >= this.Length)\r\n                throw new ArgumentOutOfRangeException();\r\n        }\r\n\r\n        //#if !AXIOM_SAFE_ONLY\r\n        public abstract IntPtr Pin();\r\n\r\n#if NET_40\r\n\t\tpublic void UnPin( bool all = false )\r\n#else\r\n        public void UnPin(bool all)\r\n#endif\r\n {\r\n            if (this.PinHandle.IsAllocated && (all || Interlocked.Decrement(ref this.PinCount) == 0)) {\r\n                lock (_mutex) {\r\n                    this.PinHandle.Free();\r\n                    this.PinCount = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n#if !NET_40\r\n        public void UnPin() {\r\n            UnPin(false);\r\n        }\r\n#endif\r\n\r\n        //#endif\r\n\r\n#if AXIOM_SAFE_MIX\r\n\t\tpublic static BufferBase Wrap( byte[] buffer )\r\n\t\t{\r\n\t\t\treturn new ManagedBuffer( buffer );\r\n\t\t}\r\n\r\n\t\tpublic static BufferBase Wrap( IntPtr buffer, int length )\r\n\t\t{\r\n\t\t\treturn new UnsafeBuffer( buffer, length );\r\n\t\t}\r\n\r\n\t\tpublic static BufferBase Wrap( object buffer, int length = 0 )\r\n\t\t{\r\n\t\t\treturn new UnsafeBuffer( buffer, length );\r\n\t\t}\r\n#elif AXIOM_SAFE_ONLY\r\n\t\tpublic static BufferBase Wrap( byte[] buffer )\r\n\t\t{\r\n\t\t\treturn new ManagedBuffer( buffer );\r\n\t\t}\r\n\r\n\t\tpublic static BufferBase Wrap( IntPtr buffer, int length )\r\n\t\t{\r\n\t\t\treturn new ManagedBuffer( buffer, length );\r\n\t\t}\r\n\r\n\t\tpublic static BufferBase Wrap( object buffer, int length = 0 )\r\n\t\t{\r\n\t\t\treturn new ManagedBuffer( buffer );\r\n\t\t}\r\n#else\r\n        public static BufferBase Wrap(byte[] buffer) {\r\n            return new UnsafeBuffer(buffer, buffer.Length);\r\n        }\r\n\r\n        public static BufferBase Wrap(IntPtr buffer, int length) {\r\n            return new UnsafeBuffer(buffer, length);\r\n        }\r\n\r\n        public static BufferBase Wrap(object buffer, int length) {\r\n            return new UnsafeBuffer(buffer, length);\r\n        }\r\n#endif\r\n\r\n#if AXIOM_SAFE_ONLY\r\n\t\tpublic ITypePointer<byte> ToBytePointer()\r\n\t\t{\r\n\t\t\treturn this as ITypePointer<byte>;\r\n\t\t}\r\n\r\n\t\tpublic ITypePointer<short> ToShortPointer()\r\n\t\t{\r\n\t\t\treturn this as ITypePointer<short>;\r\n\t\t}\r\n\r\n\t\tpublic ITypePointer<ushort> ToUShortPointer()\r\n\t\t{\r\n\t\t\treturn this as ITypePointer<ushort>;\r\n\t\t}\r\n\r\n\t\tpublic ITypePointer<int> ToIntPointer()\r\n\t\t{\r\n\t\t\treturn this as ITypePointer<int>;\r\n\t\t}\r\n\r\n\t\tpublic ITypePointer<uint> ToUIntPointer()\r\n\t\t{\r\n\t\t\treturn this as ITypePointer<uint>;\r\n\t\t}\r\n\r\n\t\tpublic ITypePointer<long> ToLongPointer()\r\n\t\t{\r\n\t\t\treturn this as ITypePointer<long>;\r\n\t\t}\r\n\r\n\t\tpublic ITypePointer<ulong> ToULongPointer()\r\n\t\t{\r\n\t\t\treturn this as ITypePointer<ulong>;\r\n\t\t}\r\n\r\n\t\tpublic ITypePointer<float> ToFloatPointer()\r\n\t\t{\r\n\t\t\treturn this as ITypePointer<float>;\r\n\t\t}\r\n\r\n\t\tpublic ITypePointer<double> ToDoublePointer()\r\n\t\t{\r\n\t\t\treturn this as ITypePointer<double>;\r\n\t\t}\r\n#else\r\n        public unsafe byte* ToBytePointer() {\r\n            return (byte*)Pin();\r\n        }\r\n\r\n        public unsafe short* ToShortPointer() {\r\n            return (short*)Pin();\r\n        }\r\n\r\n        public unsafe ushort* ToUShortPointer() {\r\n            return (ushort*)Pin();\r\n        }\r\n\r\n        public unsafe int* ToIntPointer() {\r\n            return (int*)Pin();\r\n        }\r\n\r\n        public unsafe uint* ToUIntPointer() {\r\n            return (uint*)Pin();\r\n        }\r\n\r\n        public unsafe long* ToLongPointer() {\r\n            return (long*)Pin();\r\n        }\r\n\r\n        public unsafe ulong* ToULongPointer() {\r\n            return (ulong*)Pin();\r\n        }\r\n\r\n        public unsafe float* ToFloatPointer() {\r\n            return (float*)Pin();\r\n        }\r\n\r\n        public unsafe double* ToDoublePointer() {\r\n            return (double*)Pin();\r\n        }\r\n#endif\r\n    };\r\n\r\n    public class ManagedBuffer\r\n        : BufferBase, ITypePointer<byte>, ITypePointer<short>, ITypePointer<ushort>, ITypePointer<int>, ITypePointer<uint>,\r\n          ITypePointer<long>, ITypePointer<ulong>, ITypePointer<float>, ITypePointer<double> {\r\n        protected internal readonly byte[] Buf;\r\n        protected internal int IdxPtr;\r\n        private object obj;\r\n        private static readonly object _pinMutex = new object();\r\n\r\n        public override int Ptr {\r\n            get {\r\n                return this.IdxPtr;\r\n            }\r\n            set {\r\n                this.IdxPtr = value;\r\n            }\r\n        }\r\n\r\n        public override int Length {\r\n            get {\r\n                return this.Buf.Length;\r\n            }\r\n        }\r\n\r\n        public ManagedBuffer(ManagedBuffer buffer)\r\n            : base() {\r\n            this.Buf = buffer.Buf;\r\n            this.IdxPtr = buffer.IdxPtr;\r\n        }\r\n\r\n        public ManagedBuffer(byte[] buffer)\r\n            : base() {\r\n            this.Buf = buffer;\r\n        }\r\n\r\n        public ManagedBuffer(object buffer)\r\n            : base() {\r\n            this.obj = buffer;\r\n            int size;\r\n            var t = this.obj.GetType();\r\n            if (t.IsArray) {\r\n                var buf = (Array)this.obj;\r\n                var te = t.GetElementType();\r\n                size = buf.Length * te.Size();\r\n                this.Buf = new byte[size];\r\n                if (te.IsPrimitive) {\r\n                    Buffer.BlockCopy(buf, 0, this.Buf, 0, size);\r\n                    return;\r\n                }\r\n                this.Buf.CopyFrom(buf);\r\n                return;\r\n            }\r\n            size = t.Size();\r\n            this.Buf = new byte[size];\r\n            this.Buf.CopyFrom(this.obj);\r\n        }\r\n\r\n        public ManagedBuffer(IntPtr buffer, int size)\r\n            : base() {\r\n            this.obj = buffer;\r\n            this.Buf = new byte[size];\r\n            Marshal.Copy(buffer, this.Buf, 0, size);\r\n        }\r\n\r\n        protected override void dispose(bool disposeManagedResources) {\r\n            if (!IsDisposed) {\r\n                if (disposeManagedResources && this.obj != null) {\r\n                    if (this.obj is IntPtr) {\r\n                        Marshal.Copy(this.Buf, 0, (IntPtr)this.obj, this.Length);\r\n                    }\r\n                    else {\r\n                        var t = this.obj.GetType();\r\n                        if (t.IsArray) {\r\n                            if (t.GetElementType().IsPrimitive) {\r\n                                Buffer.BlockCopy(this.Buf, 0, (Array)this.obj, 0, this.Length);\r\n                            }\r\n                            else {\r\n                                this.Buf.CopyTo((Array)this.obj);\r\n                            }\r\n                        }\r\n                        else {\r\n                            this.Buf.CopyTo(ref this.obj);\r\n                        }\r\n                    }\r\n                    this.obj = null;\r\n                }\r\n            }\r\n\r\n            base.dispose(disposeManagedResources);\r\n        }\r\n\r\n        public override object Clone() {\r\n            return new ManagedBuffer(this);\r\n        }\r\n\r\n        public override void Copy(BufferBase src, int srcOffset, int destOffset, int length) {\r\n            base.Copy(src, srcOffset, destOffset, length);\r\n\r\n            if (src is ManagedBuffer) {\r\n                Buffer.BlockCopy((src as ManagedBuffer).Buf, (src as ManagedBuffer).IdxPtr + srcOffset, this.Buf,\r\n                                  this.IdxPtr + destOffset, length);\r\n            }\r\n#if !AXIOM_SAFE_ONLY\r\n            else if (src is UnsafeBuffer) {\r\n                Marshal.Copy((IntPtr)((int)src.Pin() + srcOffset), this.Buf, this.IdxPtr + destOffset, length);\r\n                src.UnPin();\r\n            }\r\n#endif\r\n        }\r\n\r\n        public override IntPtr Pin() {\r\n            if (Interlocked.Increment(ref PinCount) > 0) {\r\n                lock (_pinMutex) {\r\n                    return\r\n                        new IntPtr(\r\n                            (PinHandle.IsAllocated ? PinHandle : PinHandle = GCHandle.Alloc(this.Buf, GCHandleType.Pinned)).\r\n                                AddrOfPinnedObject().ToInt32() + this.IdxPtr);\r\n                }\r\n            }\r\n            throw new AxiomException(\"LockCount <= 0\");\r\n        }\r\n\r\n        //---------------------------------------------------------------------\r\n\r\n        byte ITypePointer<byte>.this[int index] {\r\n            get {\r\n                checkBounds(index + this.IdxPtr);\r\n                return this.Buf[index + this.IdxPtr];\r\n            }\r\n            set {\r\n                checkBounds(index + this.IdxPtr);\r\n                this.Buf[index + this.IdxPtr] = value;\r\n            }\r\n        }\r\n\r\n        short ITypePointer<short>.this[int index] {\r\n            get {\r\n                var buf = this.Buf;\r\n                index <<= 1;\r\n                checkBounds(index + this.IdxPtr + 1);\r\n                return new TwoByte {\r\n                    b0 = buf[index += this.IdxPtr],\r\n                    b1 = buf[++index],\r\n                }.Short;\r\n            }\r\n            set {\r\n                var buf = this.Buf;\r\n                index <<= 1;\r\n                checkBounds(index + this.IdxPtr + 1);\r\n                var v = new TwoByte {\r\n                    Short = value\r\n                };\r\n                buf[index += this.IdxPtr] = v.b0;\r\n                buf[++index] = v.b1;\r\n            }\r\n        }\r\n\r\n        ushort ITypePointer<ushort>.this[int index] {\r\n            get {\r\n                var buf = this.Buf;\r\n                index <<= 1;\r\n                checkBounds(index + this.IdxPtr + 1);\r\n                return new TwoByte {\r\n                    b0 = buf[index += this.IdxPtr],\r\n                    b1 = buf[++index],\r\n                }.UShort;\r\n            }\r\n            set {\r\n                var buf = this.Buf;\r\n                index <<= 1;\r\n                checkBounds(index + this.IdxPtr + 1);\r\n                var v = new TwoByte {\r\n                    UShort = value\r\n                };\r\n                buf[index += this.IdxPtr] = v.b0;\r\n                buf[++index] = v.b1;\r\n            }\r\n        }\r\n\r\n        int ITypePointer<int>.this[int index] {\r\n            get {\r\n                var buf = this.Buf;\r\n                index <<= 2;\r\n                checkBounds(index + this.IdxPtr + 3);\r\n                return new FourByte {\r\n                    b0 = buf[index += this.IdxPtr],\r\n                    b1 = buf[++index],\r\n                    b2 = buf[++index],\r\n                    b3 = buf[++index],\r\n                }.Int;\r\n            }\r\n            set {\r\n                var buf = this.Buf;\r\n                index <<= 2;\r\n                checkBounds(index + this.IdxPtr + 3);\r\n                var v = new FourByte {\r\n                    Int = value\r\n                };\r\n                buf[index += this.IdxPtr] = v.b0;\r\n                buf[++index] = v.b1;\r\n                buf[++index] = v.b2;\r\n                buf[++index] = v.b3;\r\n            }\r\n        }\r\n\r\n        uint ITypePointer<uint>.this[int index] {\r\n            get {\r\n                var buf = this.Buf;\r\n                index <<= 2;\r\n                checkBounds(index + this.IdxPtr + 3);\r\n                return new FourByte {\r\n                    b0 = buf[index += this.IdxPtr],\r\n                    b1 = buf[++index],\r\n                    b2 = buf[++index],\r\n                    b3 = buf[++index],\r\n                }.UInt;\r\n            }\r\n            set {\r\n                var buf = this.Buf;\r\n                index <<= 2;\r\n                checkBounds(index + this.IdxPtr + 3);\r\n                var v = new FourByte {\r\n                    UInt = value\r\n                };\r\n                buf[index += this.IdxPtr] = v.b0;\r\n                buf[++index] = v.b1;\r\n                buf[++index] = v.b2;\r\n                buf[++index] = v.b3;\r\n            }\r\n        }\r\n\r\n        long ITypePointer<long>.this[int index] {\r\n            get {\r\n                var buf = this.Buf;\r\n                index <<= 3;\r\n                checkBounds(index + this.IdxPtr + 7);\r\n                return new EightByte {\r\n                    b0 = buf[index += this.IdxPtr],\r\n                    b1 = buf[++index],\r\n                    b2 = buf[++index],\r\n                    b3 = buf[++index],\r\n                    b4 = buf[++index],\r\n                    b5 = buf[++index],\r\n                    b6 = buf[++index],\r\n                    b7 = buf[++index],\r\n                }.Long;\r\n            }\r\n            set {\r\n                var buf = this.Buf;\r\n                index <<= 3;\r\n                checkBounds(index + this.IdxPtr + 7);\r\n                var v = new EightByte {\r\n                    Long = value\r\n                };\r\n                buf[index += this.IdxPtr] = v.b0;\r\n                buf[++index] = v.b1;\r\n                buf[++index] = v.b2;\r\n                buf[++index] = v.b3;\r\n                buf[++index] = v.b4;\r\n                buf[++index] = v.b5;\r\n                buf[++index] = v.b6;\r\n                buf[++index] = v.b7;\r\n            }\r\n        }\r\n\r\n        ulong ITypePointer<ulong>.this[int index] {\r\n            get {\r\n                var buf = this.Buf;\r\n                index <<= 3;\r\n                checkBounds(index + this.IdxPtr + 7);\r\n                return new EightByte {\r\n                    b0 = buf[index += this.IdxPtr],\r\n                    b1 = buf[++index],\r\n                    b2 = buf[++index],\r\n                    b3 = buf[++index],\r\n                    b4 = buf[++index],\r\n                    b5 = buf[++index],\r\n                    b6 = buf[++index],\r\n                    b7 = buf[++index],\r\n                }.ULong;\r\n            }\r\n            set {\r\n                var buf = this.Buf;\r\n                index <<= 3;\r\n                checkBounds(index + this.IdxPtr + 7);\r\n                var v = new EightByte {\r\n                    ULong = value\r\n                };\r\n                buf[index += this.IdxPtr] = v.b0;\r\n                buf[++index] = v.b1;\r\n                buf[++index] = v.b2;\r\n                buf[++index] = v.b3;\r\n                buf[++index] = v.b4;\r\n                buf[++index] = v.b5;\r\n                buf[++index] = v.b6;\r\n                buf[++index] = v.b7;\r\n            }\r\n        }\r\n\r\n        float ITypePointer<float>.this[int index] {\r\n            get {\r\n                var buf = this.Buf;\r\n                index <<= 2;\r\n                checkBounds(index + this.IdxPtr + 3);\r\n                return new FourByte {\r\n                    b0 = buf[index += this.IdxPtr],\r\n                    b1 = buf[++index],\r\n                    b2 = buf[++index],\r\n                    b3 = buf[++index],\r\n                }.Float;\r\n            }\r\n            set {\r\n                var buf = this.Buf;\r\n                index <<= 2;\r\n                checkBounds(index + this.IdxPtr + 3);\r\n                var v = new FourByte {\r\n                    Float = value\r\n                };\r\n                buf[index += this.IdxPtr] = v.b0;\r\n                buf[++index] = v.b1;\r\n                buf[++index] = v.b2;\r\n                buf[++index] = v.b3;\r\n            }\r\n        }\r\n\r\n        double ITypePointer<double>.this[int index] {\r\n            get {\r\n                var buf = this.Buf;\r\n                index <<= 3;\r\n                checkBounds(index + this.IdxPtr + 7);\r\n                return new EightByte {\r\n                    b0 = buf[index += this.IdxPtr],\r\n                    b1 = buf[++index],\r\n                    b2 = buf[++index],\r\n                    b3 = buf[++index],\r\n                    b4 = buf[++index],\r\n                    b5 = buf[++index],\r\n                    b6 = buf[++index],\r\n                    b7 = buf[++index],\r\n                }.Double;\r\n            }\r\n            set {\r\n                var buf = this.Buf;\r\n                index <<= 3;\r\n                checkBounds(index + this.IdxPtr + 7);\r\n                var v = new EightByte {\r\n                    Double = value\r\n                };\r\n                buf[index += this.IdxPtr] = v.b0;\r\n                buf[++index] = v.b1;\r\n                buf[++index] = v.b2;\r\n                buf[++index] = v.b3;\r\n                buf[++index] = v.b4;\r\n                buf[++index] = v.b5;\r\n                buf[++index] = v.b6;\r\n                buf[++index] = v.b7;\r\n            }\r\n        }\r\n    };\r\n\r\n    public class BitConvertBuffer\r\n        : ManagedBuffer, ITypePointer<short>, ITypePointer<ushort>, ITypePointer<int>, ITypePointer<uint>, ITypePointer<long>,\r\n          ITypePointer<ulong>, ITypePointer<float>, ITypePointer<double> {\r\n        public BitConvertBuffer(ManagedBuffer buffer)\r\n            : base(buffer) {\r\n        }\r\n\r\n        public BitConvertBuffer(byte[] buffer)\r\n            : base(buffer) {\r\n        }\r\n\r\n        public BitConvertBuffer(object buffer)\r\n            : base(buffer) {\r\n        }\r\n\r\n        public BitConvertBuffer(IntPtr buffer, int size)\r\n            : base(buffer, size) {\r\n        }\r\n\r\n        short ITypePointer<short>.this[int index] {\r\n            get {\r\n                var idx = (index << 1) + IdxPtr;\r\n                checkBounds(idx + 1);\r\n                return BitConverter.ToInt16(Buf, idx);\r\n            }\r\n            set {\r\n                index = (index << 1) + IdxPtr;\r\n                checkBounds(index + 1);\r\n                var v = BitConverter.GetBytes(value);\r\n                Buffer.BlockCopy(v, 0, Buf, index, sizeof(short));\r\n            }\r\n        }\r\n\r\n        ushort ITypePointer<ushort>.this[int index] {\r\n            get {\r\n                var idx = (index << 1) + IdxPtr;\r\n                checkBounds(idx + 1);\r\n                return BitConverter.ToUInt16(Buf, idx);\r\n            }\r\n            set {\r\n                index = (index << 1) + IdxPtr;\r\n                checkBounds(index + 1);\r\n                var v = BitConverter.GetBytes(value);\r\n                Buffer.BlockCopy(v, 0, Buf, index, sizeof(ushort));\r\n            }\r\n        }\r\n\r\n        int ITypePointer<int>.this[int index] {\r\n            get {\r\n                var idx = (index << 2) + IdxPtr;\r\n                checkBounds(idx + 3);\r\n                return BitConverter.ToInt32(Buf, idx);\r\n            }\r\n            set {\r\n                index = (index << 2) + IdxPtr;\r\n                checkBounds(index + 3);\r\n                var v = BitConverter.GetBytes(value);\r\n                Buffer.BlockCopy(v, 0, Buf, index, sizeof(int));\r\n            }\r\n        }\r\n\r\n        uint ITypePointer<uint>.this[int index] {\r\n            get {\r\n                var idx = (index << 2) + IdxPtr;\r\n                checkBounds(idx + 3);\r\n                return BitConverter.ToUInt32(Buf, idx);\r\n            }\r\n            set {\r\n                index = (index << 2) + IdxPtr;\r\n                checkBounds(index + 3);\r\n                var v = BitConverter.GetBytes(value);\r\n                Buffer.BlockCopy(v, 0, Buf, index, sizeof(uint));\r\n            }\r\n        }\r\n\r\n        long ITypePointer<long>.this[int index] {\r\n            get {\r\n                var idx = (index << 3) + IdxPtr;\r\n                checkBounds(idx + 7);\r\n                return BitConverter.ToInt64(Buf, idx);\r\n            }\r\n            set {\r\n                index = (index << 3) + IdxPtr;\r\n                checkBounds(index + 7);\r\n                var v = BitConverter.GetBytes(value);\r\n                Buffer.BlockCopy(v, 0, Buf, index, sizeof(long));\r\n            }\r\n        }\r\n\r\n        ulong ITypePointer<ulong>.this[int index] {\r\n            get {\r\n                var idx = (index << 3) + IdxPtr;\r\n                checkBounds(idx + 7);\r\n                return BitConverter.ToUInt64(Buf, idx);\r\n            }\r\n            set {\r\n                index = (index << 3) + IdxPtr;\r\n                checkBounds(index + 7);\r\n                var v = BitConverter.GetBytes(value);\r\n                Buffer.BlockCopy(v, 0, Buf, index, sizeof(ulong));\r\n            }\r\n        }\r\n\r\n        float ITypePointer<float>.this[int index] {\r\n            get {\r\n                var idx = (index << 2) + IdxPtr;\r\n                checkBounds(idx + 3);\r\n                return BitConverter.ToSingle(Buf, idx);\r\n            }\r\n            set {\r\n                index = (index << 2) + IdxPtr;\r\n                checkBounds(index + 3);\r\n                var v = BitConverter.GetBytes(value);\r\n                Buffer.BlockCopy(v, 0, Buf, index, sizeof(float));\r\n            }\r\n        }\r\n\r\n        double ITypePointer<double>.this[int index] {\r\n            get {\r\n                var idx = (index << 3) + IdxPtr;\r\n                checkBounds(idx + 7);\r\n                return BitConverter.ToDouble(Buf, idx);\r\n            }\r\n            set {\r\n                index = (index << 3) + IdxPtr;\r\n                checkBounds(index + 7);\r\n                var v = BitConverter.GetBytes(value);\r\n                Buffer.BlockCopy(v, 0, Buf, index, sizeof(double));\r\n            }\r\n        }\r\n    };\r\n\r\n#if !AXIOM_SAFE_ONLY\r\n    public class UnsafeBuffer\r\n        : BufferBase, ITypePointer<byte>, ITypePointer<short>, ITypePointer<ushort>, ITypePointer<int>, ITypePointer<uint>,\r\n          ITypePointer<long>, ITypePointer<ulong>, ITypePointer<float>, ITypePointer<double> {\r\n        internal readonly unsafe byte* Buf;\r\n        internal unsafe byte* PtrBuf;\r\n\r\n        public override int Ptr {\r\n            get {\r\n                unsafe {\r\n                    return (int)(this.PtrBuf - this.Buf);\r\n                }\r\n            }\r\n            set {\r\n                unsafe {\r\n                    this.PtrBuf = this.Buf + value;\r\n                }\r\n            }\r\n        }\r\n\r\n        public UnsafeBuffer(object buffer, int length)\r\n            : base() {\r\n            unsafe {\r\n                this.Buf = (byte*)(PinHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned)).AddrOfPinnedObject();\r\n                PinCount = 1;\r\n                this.PtrBuf = this.Buf;\r\n                this.Length = length;\r\n            }\r\n        }\r\n\r\n        public UnsafeBuffer(IntPtr buffer, int length)\r\n            : base() {\r\n            unsafe {\r\n                this.Buf = (byte*)buffer;\r\n                this.PtrBuf = this.Buf;\r\n                this.Length = length;\r\n            }\r\n        }\r\n\r\n        public override object Clone() {\r\n            unsafe {\r\n                return new UnsafeBuffer((IntPtr)this.Buf, Length) {\r\n                    Ptr = Ptr,\r\n                };\r\n            }\r\n        }\r\n\r\n        public override void Copy(BufferBase src, int srcOffset, int destOffset, int length) {\r\n            base.Copy(src, srcOffset, destOffset, length);\r\n\r\n            unsafe {\r\n                if (src is ManagedBuffer) {\r\n                    Marshal.Copy((src as ManagedBuffer).Buf, (src as ManagedBuffer).IdxPtr + srcOffset,\r\n                                  (IntPtr)(this.PtrBuf + destOffset), length);\r\n                }\r\n                else if (src is UnsafeBuffer) {\r\n                    var pSrc = src.ToBytePointer();\r\n                    var pDest = this.ToBytePointer();\r\n\r\n                    //Following code snippet was taken from http://msdn.microsoft.com/en-us/library/28k1s2k6(v=vs.80).aspx\r\n                    var ps = pSrc + srcOffset;\r\n                    var pd = pDest + destOffset;\r\n\r\n                    // Loop over the count in blocks of 4 bytes, copying an integer (4 bytes) at a time:\r\n                    for (var i = 0; i < length / 4; i++) {\r\n                        *((int*)pd) = *((int*)ps);\r\n                        pd += 4;\r\n                        ps += 4;\r\n                    }\r\n\r\n                    // Complete the copy by moving any bytes that weren't moved in blocks of 4:\r\n                    for (var i = 0; i < length % 4; i++) {\r\n                        *pd = *ps;\r\n                        pd++;\r\n                        ps++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public override IntPtr Pin() {\r\n            unsafe {\r\n                Interlocked.Increment(ref PinCount);\r\n                return (IntPtr)this.PtrBuf;\r\n            }\r\n        }\r\n\r\n        //---------------------------------------------------------------------\r\n\r\n        byte ITypePointer<byte>.this[int index] {\r\n            get {\r\n                unsafe {\r\n                    checkBounds(this.Ptr + index);\r\n                    return *(this.PtrBuf + index);\r\n                }\r\n            }\r\n            set {\r\n                unsafe {\r\n                    checkBounds(this.Ptr + index);\r\n                    *(this.PtrBuf + index) = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        short ITypePointer<short>.this[int index] {\r\n            get {\r\n                unsafe {\r\n                    index <<= 1;\r\n                    checkBounds(this.Ptr + index);\r\n                    return *(short*)(this.PtrBuf + index);\r\n                }\r\n            }\r\n            set {\r\n                unsafe {\r\n                    index <<= 1;\r\n                    checkBounds(this.Ptr + index);\r\n                    *(short*)(this.PtrBuf + index) = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        ushort ITypePointer<ushort>.this[int index] {\r\n            get {\r\n                unsafe {\r\n                    index <<= 1;\r\n                    checkBounds(this.Ptr + index);\r\n                    return *(ushort*)(this.PtrBuf + index);\r\n                }\r\n            }\r\n            set {\r\n                unsafe {\r\n                    index <<= 1;\r\n                    checkBounds(this.Ptr + index);\r\n                    *(ushort*)(this.PtrBuf + index) = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        int ITypePointer<int>.this[int index] {\r\n            get {\r\n                unsafe {\r\n                    index <<= 2;\r\n                    checkBounds(this.Ptr + index);\r\n                    return *(int*)(this.PtrBuf + index);\r\n                }\r\n            }\r\n            set {\r\n                unsafe {\r\n                    index <<= 2;\r\n                    checkBounds(this.Ptr + index);\r\n                    *(int*)(this.PtrBuf + index) = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        uint ITypePointer<uint>.this[int index] {\r\n            get {\r\n                unsafe {\r\n                    index <<= 2;\r\n                    checkBounds(this.Ptr + index);\r\n                    return *(uint*)(this.PtrBuf + index);\r\n                }\r\n            }\r\n            set {\r\n                unsafe {\r\n                    index <<= 2;\r\n                    checkBounds(this.Ptr + index);\r\n                    *(uint*)(this.PtrBuf + index) = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        long ITypePointer<long>.this[int index] {\r\n            get {\r\n                unsafe {\r\n                    index <<= 3;\r\n                    checkBounds(this.Ptr + index);\r\n                    return *(long*)(this.PtrBuf + index);\r\n                }\r\n            }\r\n            set {\r\n                unsafe {\r\n                    index <<= 3;\r\n                    checkBounds(this.Ptr + index);\r\n                    *(long*)(this.PtrBuf + index) = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        ulong ITypePointer<ulong>.this[int index] {\r\n            get {\r\n                unsafe {\r\n                    index <<= 3;\r\n                    checkBounds(this.Ptr + index);\r\n                    return *(ulong*)(this.PtrBuf + index);\r\n                }\r\n            }\r\n            set {\r\n                unsafe {\r\n                    index <<= 3;\r\n                    checkBounds(this.Ptr + index);\r\n                    *(ulong*)(this.PtrBuf + index) = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        float ITypePointer<float>.this[int index] {\r\n            get {\r\n                unsafe {\r\n                    index <<= 2;\r\n                    checkBounds(this.Ptr + index);\r\n                    return *(float*)(this.PtrBuf + index);\r\n                }\r\n            }\r\n            set {\r\n                unsafe {\r\n                    index <<= 2;\r\n                    checkBounds(this.Ptr + index);\r\n                    *(float*)(this.PtrBuf + index) = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        double ITypePointer<double>.this[int index] {\r\n            get {\r\n                unsafe {\r\n                    index <<= 3;\r\n                    checkBounds(this.Ptr + index);\r\n                    return *(double*)(this.PtrBuf + index);\r\n                }\r\n            }\r\n            set {\r\n                unsafe {\r\n                    index <<= 3;\r\n                    checkBounds(this.Ptr + index);\r\n                    *(double*)(this.PtrBuf + index) = value;\r\n                }\r\n            }\r\n        }\r\n    };\r\n#endif\r\n}\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}